---
title: Récolte de bois départementale
toc: false
sql:
  recolte_departements_historique: ./data/recolte_departements_historique.csv
---

To do : Treemap de toutes les essences avec filtre par département et par année \n
To do : Cartes pour afficher des indicateurs clés (ou une phrase avec paramètres intégrés). 

<h1> Récolte de bois départementale </h1>









```js
import { select, table } from "@observablehq/inputs";
import {createOptionsEChartsFromData} from "./components/graphHisto.js";
//import * as Plot from "npm:@observablehq/plot";
//import {treemap, hierarchy, scaleOrdinal, schemeCategory10} from "d3"
```


<!-- ------------------------------
Requêtes SQL pour listes dynamiques
-------------------------------- -->


```sql id=liste_departements
/*Requête pour obtenir la liste des départements*/ 
SELECT DISTINCT Département as departements
FROM recolte_departements_historique
```

```sql id=liste_essences
/*Requête pour obtenir la liste des essences*/ 
SELECT DISTINCT Récolte as essences 
FROM recolte_departements_historique
```

```sql id=borne_annees
/*Requête pour obtenir la liste des années*/ 
SELECT 
  MIN(CAST(column_name AS INTEGER)) AS annee_min,
  MAX(CAST(column_name AS INTEGER)) AS annee_max
FROM (
  SELECT column_name
  FROM information_schema.columns
  WHERE table_name='recolte_departements_historique'
  AND column_name LIKE '____' -- 4 caractères
)
```

```js
/*Création de la liste des années à partir des bornes obtenues dans la requête*/ 
const { annee_min, annee_max } = borne_annees.toArray()[0];
const annees = Array.from(
  { length: annee_max - annee_min + 1 }, 
  (_, i) => (annee_min + i).toString()
);
```

```js
/*Mise en forme*/ 
const tab_departements = liste_departements.toArray();
const tab_essences = liste_essences.toArray();
```

```js
/*Mise en forme*/ 
const noms_departements = tab_departements.map(d => d.departements);
const noms_essences = tab_essences.map(d => d.essences);

```

```js
/*Affichage des 3 listes de paramètres dynamiques*/ 
const choix_liste_departements1 = view(Inputs.select(noms_departements, { label: "Choississez un département :"}));
const choix_liste_essences1 = view(Inputs.select(noms_essences, { label: "Choisissez une essence :"}));
const choix_list_annee1 = view(Inputs.select(annees, { label: "Choisissez une année :"}));
```

(Optionnel) Vous pouvez choisir un second département à comparer 

```js
/*Affichage des listes de paramètres dynamiques*/ 
const choix_liste_departements2 = view(Inputs.select(noms_departements));
```

```sql id=test1
SELECT * 
FROM recolte_departements_historique 
WHERE Département=${choix_liste_departements1} 
AND Récolte=${choix_liste_essences1}
```

```sql id=test2
SELECT * 
FROM recolte_departements_historique 
WHERE Département=${choix_liste_departements2} 
AND Récolte=${choix_liste_essences1}
```

```sql id=test3
SELECT * 
FROM recolte_departements_historique 
WHERE Département='France métropolitaine'
AND Récolte=${choix_liste_essences1}
```

```js
const sql = `
SELECT Département, Récolte, "${choix_list_annee1}" AS valeur
FROM recolte_departements_historique 
WHERE Département=${choix_liste_departements1}`
```







Charger les données csv sans sql

```js
const fichier_recolte = await FileAttachment("./data/recolte_departements_historique.csv").dsv({delimiter: ";", array: true})
const headers = fichier_recolte[0];
const rows = fichier_recolte.slice(1);
```

```js
const data = rows.map(row => {
  const obj = {};
  headers.forEach((header, index) => {
    obj[header] = row[index];
  });
  return obj;
});
```

```js
const yearColumns = headers.filter(header => header.match(/^20\d{2}$/)); // Filtre les colonnes comme "2005", "2024", etc.

const selectedYear = view(
  Inputs.select(yearColumns, {
    label: "Sélectionnez une année",
    value: yearColumns[yearColumns.length - 1] // Valeur par défaut : dernière année
  })
);
```
```js
const fin = data.map(row => ({
    Département: row["Département"],
    Récolte: row["Récolte"],
    Valeur: row[selectedYear]
  }));

```

```js
fin
```


Fin chargement des données csv sans sql

```js
const table_filtree1 = test1.toArray();
const table_filtree2 = test2.toArray();
const table_filtree3 = test3.toArray();
const table_filtree4 = test4.toArray();
```

```js
// On récupère la première ligne
const row1 = table_filtree1[0];
const row2 = table_filtree2[0];
const row3 = table_filtree3[0];
const row4 = table_filtree4[0];
```

```js
// On crée un tableau "long" {Departement, Annee, Volume}
const data_long1 = table_filtree1.flatMap(row1 => {
  const years1 = Object.keys(row1).filter(d => /^\d{4}$/.test(d));
  return years1.map(y => ({
    Departement: row1.Département,
    Annee: +y,
    Volume: parseFloat(row1[y].replace(",", "."))
  }));
});

const data_long2 = table_filtree2.flatMap(row2 => {
  const years2 = Object.keys(row2).filter(d => /^\d{4}$/.test(d));
  return years2.map(y => ({
    Departement: row2.Département,
    Annee: +y,
    Volume: parseFloat(row2[y].replace(",", "."))
  }));
});

const data_long3 = table_filtree3.flatMap(row3 => {
  const years3 = Object.keys(row3).filter(d => /^\d{4}$/.test(d));
  return years3.map(y => ({
    Departement: row3.Département,
    Annee: +y,
    Volume: parseFloat(row3[y].replace(",", "."))
  }));
});

const data_long4 = table_filtree4.flatMap(row4 => {
  const years4 = Object.keys(row4).filter(d => /^\d{4}$/.test(d));
  return years4.map(y => ({
    Departement: row4.Département,
    Annee: +y,
    Essence: row4.Récolte,
    Volume: parseFloat(row4[y].replace(",", "."))
  }));
});
```

```js
const maxVolume1 = Math.max(...data_long1.map(d => d.Volume));
const maxVolume2 = Math.max(...data_long2.map(d => d.Volume));
const maxVolume = Math.max(maxVolume1, maxVolume2);

const maxVolume3 = Math.max(...data_long3.map(d => d.Volume));
```

```js
Plot.plot({
  width: 800,
  height: 400,
  x: {
    label: "Année",
    tickFormat: d => d.toString(), // texte pour l'axe X
  },
  y: {
    label: "Volume (en milliers de m3 ronds sur écorce)",
    domain: [0, maxVolume * 1.1]   // axe Y à partir de 0
  },
  color: {legend: true}, // légende pour différencier les départements
  marks: [
    // première courbe
    Plot.line(data_long1, {x: "Annee", y: "Volume", stroke: "Departement"}),
    Plot.dot(data_long1, {x: "Annee", y: "Volume", fill: "Departement",
                     title: d => `${d.Departement}\n${d.Annee}: ${d.Volume}`}),
    
    // deuxième courbe
    Plot.line(data_long2, {x: "Annee", y: "Volume", stroke: "Departement"}),
    Plot.dot(data_long2, {x: "Annee", y: "Volume", fill: "Departement",
                     title: d => `${d.Departement}\n${d.Annee}: ${d.Volume}`}),

    // troisième courbe
    Plot.line(data_long3, {x: "Annee", y: "Volume", stroke: "Departement"}),
    Plot.dot(data_long3, {x: "Annee", y: "Volume", fill: "Departement",
                     title: d => `${d.Departement}\n${d.Annee}: ${d.Volume}`})
  ]
})
```

```js
Plot.plot({
    x: {tickFormat: ""}, 
    y: {axis: "left", label: "Volume des départements (en milliers de m3 ronds sur écorce)", domain: [0, maxVolume3 * 1.1]}, 
    marks: [
      Plot.axisY({color: "steelblue", anchor: "right", label: "Volume de la France métropolitaine (en milliers de m3 ronds sur écorce)", data_long1}),
      Plot.ruleY([0]),
      Plot.lineY(data_long1, {x: "Annee", y: "Volume", stroke: "Departement"}),
      Plot.lineY(data_long2, {x: "Annee", y: "Volume", stroke: "Departement"}),
      Plot.lineY(data_long3, {x: "Annee", y: "Volume", stroke: "Departement"})
    ]
  })
```

```js
data_long4
```

```js
Treemap(data_long4, {
  path: (d) => d.Récolte ,
  label: (d) => d.Récolte, // display text
  group: (d) => d.Récolte,
  value: (d) => d.Volume,
  tile: d3.treemapSquarify,
  fontsize : 200
})
```

```js
// Copyright 2021-2023 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/treemap
function Treemap(data, { // data is either tabular (array of objects) or hierarchy (nested objects)
  path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
  id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
  parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
  children, // if hierarchical data, given a d in data, returns its children
  value, // given a node d, returns a quantitative value (for area encoding; null for count)
  sort = (a, b) => d3.descending(a.value, b.value), // how to sort nodes prior to layout
  label, // given a leaf node d, returns the name to display on the rectangle
  group, // given a leaf node d, returns a categorical value (for color encoding)
  title, // given a leaf node d, returns its hover text
  link, // given a leaf node d, its link (if any)
  linkTarget = "_blank", // the target attribute for links (if any)
  tile = d3.treemapBinary, // treemap strategy
  width = 640, // outer width, in pixels
  height = 400, // outer height, in pixels
  margin = 0, // shorthand for margins
  marginTop = margin, // top margin, in pixels
  marginRight = margin, // right margin, in pixels
  marginBottom = margin, // bottom margin, in pixels
  marginLeft = margin, // left margin, in pixels
  padding = 1, // shorthand for inner and outer padding
  paddingInner = padding, // to separate a node from its adjacent siblings
  paddingOuter = padding, // shorthand for top, right, bottom, and left padding
  paddingTop = paddingOuter, // to separate a node’s top edge from its children
  paddingRight = paddingOuter, // to separate a node’s right edge from its children
  paddingBottom = paddingOuter, // to separate a node’s bottom edge from its children
  paddingLeft = paddingOuter, // to separate a node’s left edge from its children
  round = true, // whether to round to exact pixels
  colors = d3.schemeTableau10, // array of colors
  zDomain, // array of values for the color scale
  fill = "#ccc", // fill for node rects (if no group color encoding)
  fillOpacity = group == null ? null : 0.6, // fill opacity for node rects
  stroke, // stroke for node rects
  strokeWidth, // stroke width for node rects
  strokeOpacity, // stroke opacity for node rects
  strokeLinejoin, // stroke line join for node rects
} = {}) {

  // If id and parentId options are specified, or the path option, use d3.stratify
  // to convert tabular data to a hierarchy; otherwise we assume that the data is
  // specified as an object {children} with nested objects (a.k.a. the “flare.json”
  // format), and use d3.hierarchy.

  // We take special care of any node that has both a value and children, see
  // https://observablehq.com/@d3/treemap-parent-with-value.
  const stratify = data => (d3.stratify().path(path)(data)).each(node => {
    if (node.children?.length && node.data != null) {
      const child = new d3.Node(node.data);
      node.data = null;
      child.depth = node.depth + 1;
      child.height = 0;
      child.parent = node;
      child.id = node.id + "/";
      node.children.unshift(child);
    }
  });
  const root = path != null ? stratify(data)
      : id != null || parentId != null ? d3.stratify().id(id).parentId(parentId)(data)
      : d3.hierarchy(data, children);

  // Compute the values of internal nodes by aggregating from the leaves.
  value == null ? root.count() : root.sum(d => Math.max(0, d ? value(d) : null));

  // Prior to sorting, if a group channel is specified, construct an ordinal color scale.
  const leaves = root.leaves();
  const G = group == null ? null : leaves.map(d => group(d.data, d));
  if (zDomain === undefined) zDomain = G;
  zDomain = new d3.InternSet(zDomain);
  const color = group == null ? null : d3.scaleOrdinal(zDomain, colors);

  // Compute labels and titles.
  const L = label == null ? null : leaves.map(d => label(d.data, d));
  const T = title === undefined ? L : title == null ? null : leaves.map(d => title(d.data, d));

  // Sort the leaves (typically by descending value for a pleasing layout).
  if (sort != null) root.sort(sort);

  // Compute the treemap layout.
  d3.treemap()
      .tile(tile)
      .size([width - marginLeft - marginRight, height - marginTop - marginBottom])
      .paddingInner(paddingInner)
      .paddingTop(paddingTop)
      .paddingRight(paddingRight)
      .paddingBottom(paddingBottom)
      .paddingLeft(paddingLeft)
      .round(round)
    (root);

  const svg = d3.create("svg")
      .attr("viewBox", [-marginLeft, -marginTop, width, height])
      .attr("width", width)
      .attr("height", height)
      .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
      .attr("font-family", "sans-serif")
      .attr("font-size", 10);

  const node = svg.selectAll("a")
    .data(leaves)
    .join("a")
      .attr("xlink:href", link == null ? null : (d, i) => link(d.data, d))
      .attr("target", link == null ? null : linkTarget)
      .attr("transform", d => `translate(${d.x0},${d.y0})`);

  node.append("rect")
      .attr("fill", color ? (d, i) => color(G[i]) : fill)
      .attr("fill-opacity", fillOpacity)
      .attr("stroke", stroke)
      .attr("stroke-width", strokeWidth)
      .attr("stroke-opacity", strokeOpacity)
      .attr("stroke-linejoin", strokeLinejoin)
      .attr("width", d => d.x1 - d.x0)
      .attr("height", d => d.y1 - d.y0);

  if (T) {
    node.append("title").text((d, i) => T[i]);
  }

  if (L) {
    // A unique identifier for clip paths (to avoid conflicts).
    const uid = `O-${Math.random().toString(16).slice(2)}`;

    node.append("clipPath")
       .attr("id", (d, i) => `${uid}-clip-${i}`)
     .append("rect")
       .attr("width", d => d.x1 - d.x0)
       .attr("height", d => d.y1 - d.y0);

    node.append("text")
        .attr("clip-path", (d, i) => `url(${new URL(`#${uid}-clip-${i}`, location)})`)
      .selectAll("tspan")
      .data((d, i) => `${L[i]}`.split(/\n/g))
      .join("tspan")
        .attr("x", 3)
        .attr("y", (d, i, D) => `${(i === D.length - 1) * 0.3 + 1.1 + i * 0.9}em`)
        .attr("fill-opacity", (d, i, D) => i === D.length - 1 ? 0.7 : null)
        .text(d => d);   
  }

  return Object.assign(svg.node(), {scales: {color}});
}
```

























```js
const tableauUnique = data_long1.map((d, i) => ({
  Annee: d.Annee,
  "Departement1": d.Volume,         // ou d.Departement si tu veux le nom
  "Departement2": data_long2[i].Volume,
  "Departement3": data_long3[i].Volume
}));
```



```js
// Ceci est le graphique à modifier 
Plot.plot({
  x: {tickFormat: ""},
  y: {axis: "right", label: "Volume de la France métropolitaine (en milliers de m3 ronds sur écorce)", transform: (d) => d},
  marks: [
    Plot.axisY({color: "steelblue", anchor: "left", label: "Volume des départements (en milliers de m3 ronds sur écorce)",  y: d3.scaleLinear(d3.extent(tableauUnique, (d) => d.Departement2), [0, d3.max(tableauUnique, (d) => d.Departement1)])}),
    Plot.lineY(tableauUnique, {x: "Annee", y: "Departement1"}),
    Plot.lineY(tableauUnique, {x: "Annee", y: "Departement2"}),
    Plot.lineY(tableauUnique, {x: "Annee", y: "Departement3"})
  ]
})
```

